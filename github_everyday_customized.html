<!DOCTYPE html>
<html>
<head>
<title>github_everyday_customized.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>

</style>





</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="giteveryday---a-useful-minimum-set-of-commands-for-everyday-git">giteveryday - A useful minimum set of commands for Everyday Git:</h2>
<blockquote>
<p>SYNOPSIS</p>
</blockquote>
<p>Everyday Git With 20 Commands Or So</p>
<blockquote>
<p>DESCRIPTION:</p>
</blockquote>
<p><b>Git users can broadly be grouped into four categories for the purposes
of describing here a small set of useful command for everyday Git.</b></p>
<ul>
<li>
<p><strong>Individual Developer (Standalone) commands</strong> are essential for
anybody who makes a commit, even for somebody who works alone.</p>
</li>
<li>
<p>If you work with other people, you will need commands listed in the
<strong>Individual Developer (Participant)</strong> section as well.</p>
</li>
<li>
<p>People who play the <strong>Integrator role</strong> need to learn some more
commands in addition to the above.</p>
</li>
<li>
<p><strong>Repository Administration</strong> commands are for system administrators
who are responsible for the care and feeding of Git repositories.</p>
</li>
</ul>
<h2 id="individual-developer-standalone">INDIVIDUAL DEVELOPER (STANDALONE)</h2>
<blockquote>
<p>A standalone individual developer does not exchange patches with other people, and works alone in a single repository, using the following commands:</p>
</blockquote>
<ul>
<li>git-init(1) to create a new repository.</li>
<li>git-log(1) to see what happened.</li>
<li>git-checkout(1) and git-branch(1) to switch branches.</li>
<li>git-add(1) to manage the index file.</li>
<li>git-diff(1) and git-status(1) to see what you are in the middle of doing.</li>
<li>git-commit(1) to advance the current branch.</li>
<li>git-reset(1) and git-checkout(1) (with pathname parameters) to undo changes.</li>
<li>git-merge(1) to merge between local branches.</li>
<li>git-rebase(1) to maintain topic branches.</li>
<li>git-tag(1) to mark a known point.</li>
</ul>
<h4 id="examples">Examples</h4>
<blockquote>
<p>Use a tarball as a starting point for a new repository.</p>
</blockquote>
<pre class="hljs"><code><div>       $ tar zxf frotz.tar.gz
       $ <span class="hljs-built_in">cd</span> frotz
       $ git init
       $ git add .  <span class="hljs-comment">#add everything under the current directory.</span>
       $ git commit -m <span class="hljs-string">"import of frotz source tree."</span>
       $ git tag v2.43 <span class="hljs-comment">#make a lightweight, unannotated tag.      </span>
</div></code></pre>
<blockquote>
<p>Create a topic branch and develop.</p>
</blockquote>
<pre><code>     $ git checkout -b alsa-audio (1)
     $ edit/compile/test
     $ git checkout -- curses/ux_audio_oss.c (2)
     $ git add curses/ux_audio_alsa.c (3)
     $ edit/compile/test
     $ git diff HEAD (4)
     $ git commit -a -s (5)
     $ edit/compile/test
     $ git diff HEAD^ (6)
     $ git commit -a --amend (7)
     $ git checkout master (8)
     $ git merge alsa-audio (9)
     $ git log --since='3 days ago' (10)
     $ git log v2.43.. curses/ (11)

 1. create a new topic branch.
 2. revert your botched changes in curses/ux_audio_oss.c.
 3. you need to tell Git if you added a new file; removal and
 modification will be caught if you do git commit -a later.
 4. to see what changes you are committing.
 5. commit everything, as you have tested, with your sign-off.
 6. look at all your changes including the previous commit.
 7. amend the previous commit, adding all your new changes, using
 your original message.
 8. switch to the master branch.
 9. merge a topic branch into your master branch.
 10. review commit logs; other forms to limit output can be combined
 and include -10 (to show up to 10 commits), --until=2005-12-10,
 etc.
 11. view only the changes that touch what’s in curses/ directory,
 since v2.43 tag.
</code></pre>
<h2 id="individual-developer-participant">INDIVIDUAL DEVELOPER (PARTICIPANT)</h2>
<p>A developer working as a participant in a group project needs to learn
how to communicate with others, and uses these commands in addition to
the ones needed by a standalone developer.</p>
<ul>
<li>git-clone(1) from the upstream to prime your local repository.</li>
<li>git-pull(1) and git-fetch(1) from &quot;origin&quot; to keep up-to-date with
the upstream.</li>
<li>git-push(1) to shared repository, if you adopt CVS style shared
repository workflow.</li>
<li>git-format-patch(1) to prepare e-mail submission, if you adopt
Linux kernel-style public forum workflow.</li>
<li>git-send-email(1) to send your e-mail submission without corruption
by your MUA.</li>
<li>git-request-pull(1) to create a summary of changes for your
upstream to pull.</li>
</ul>
<h4 id="examples">Examples</h4>
<blockquote>
<p>Clone the upstream and work on it. Feed changes to upstream.</p>
</blockquote>
<pre class="hljs"><code><div>   $ git <span class="hljs-built_in">clone</span> git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6
   $ <span class="hljs-built_in">cd</span> my2.6
   $ git checkout -b mine master (1)
   $ edit/compile/<span class="hljs-built_in">test</span>; git commit -a -s (2)
   $ git format-patch master (3)
   $ git send-email --to=<span class="hljs-string">"person &lt;email@example.com&gt;"</span> 00*.patch (4)
   $ git checkout master (5)
   $ git pull (6)
   $ git <span class="hljs-built_in">log</span> -p ORIG_HEAD.. arch/i386 include/asm-i386 (7)
   $ git ls-remote --heads http://git.kernel.org/.../jgarzik/libata-dev.git (8)
   $ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL (9)
   $ git reset --hard ORIG_HEAD (10)
   $ git gc (11)
</div></code></pre>
<ol>
<li>checkout a new branch mine from master.</li>
<li>repeat as needed.</li>
<li>extract patches from your branch, relative to master,</li>
<li>and email them.</li>
<li>return to master, ready to see what’s new</li>
<li>git pull fetches from origin by default and merges into the
current branch.</li>
<li>immediately after pulling, look at the changes done upstream
since last time we checked, only in the area we are interested in.</li>
<li>check the branch names in an external repository (if not known).</li>
<li>fetch from a specific branch ALL from a specific repository and
merge it.</li>
<li>revert the pull.</li>
<li>garbage collect leftover objects from reverted pull.</li>
</ol>
<blockquote>
<p>Push into another repository.</p>
</blockquote>
<pre class="hljs"><code><div>satellite$ git <span class="hljs-built_in">clone</span> mothership:frotz frotz (1)
satellite$ <span class="hljs-built_in">cd</span> frotz
satellite$ git config --get-regexp <span class="hljs-string">'^(remote|branch)\.'</span> (2)
    remote.origin.url mothership:frotz
    remote.origin.fetch refs/heads/*:refs/remotes/origin/*
    branch.master.remote origin
    branch.master.merge refs/heads/master
satellite$ git config remote.origin.push \
    +refs/heads/*:refs/remotes/satellite/* (3)
    satellite$ edit/compile/<span class="hljs-built_in">test</span>/commit
         satellite$ git push origin (4)

    mothership$ <span class="hljs-built_in">cd</span> frotz
    mothership$ git checkout master
    mothership$ git merge satellite/master (5)
</div></code></pre>
<pre><code> 1. mothership machine has a frotz repository under your home
 directory; clone from it to start a repository on the satellite
 machine.
 2. clone sets these configuration variables by default. It arranges
 git pull to fetch and store the branches of mothership machine to
 local remotes/origin/* remote-tracking branches.
 3. arrange git push to push all local branches to their
 corresponding branch of the mothership machine.
 4. push will stash all our work away on remotes/satellite/*
 remote-tracking branches on the mothership machine. You could use
 this as a back-up method. Likewise, you can pretend that mothership
 &quot;fetched&quot; from you (useful when access is one sided).
 5. on mothership machine, merge the work done on the satellite
 machine into the master branch.
</code></pre>
<blockquote>
<p>Branch off of a specific tag.</p>
</blockquote>
<pre class="hljs"><code><div>    $ git checkout -b private2.6.14 v2.6.14 (1)
    $ edit/compile/<span class="hljs-built_in">test</span>; git commit -a
    $ git checkout master
    $ git cherry-pick v2.6.14..private2.6.14 (2)

     1. create a private branch based on a well known (but somewhat
     behind) tag.
     2. forward port all changes <span class="hljs-keyword">in</span> private2.6.14 branch to master
     branch without a formal <span class="hljs-string">"merging"</span>. Or longhand

     git format-patch -k -m --stdout v2.6.14..private2.6.14 | git am -3
     -k
</div></code></pre>
<p>An alternate participant submission mechanism is using the git
request-pull or pull-request mechanisms (e.g as used on GitHub
(www.github.com) to notify your upstream of your contribution.</p>
<h2 id="integrator">INTEGRATOR</h2>
<p>A fairly central person acting as the integrator in a group project
receives changes made by others, reviews and integrates them and
publishes the result for others to use, <strong>using these commands in
addition to the ones needed by participants</strong>.</p>
<p>This section can also be used by those who respond to git request-pull
or pull-request on GitHub (www.github.com) to integrate the work of
others into their history. An sub-area lieutenant for a repository will
act both as a participant and as an integrator.</p>
<ul>
<li>git-am(1) to apply patches e-mailed in from your contributors.</li>
<li>git-pull(1) to merge from your trusted lieutenants.</li>
<li>git-format-patch(1) to prepare and send suggested alternative to
contributors.</li>
<li>git-revert(1) to undo botched commits.</li>
<li>git-push(1) to publish the bleeding edge.</li>
</ul>
<h4 id="examples">Examples</h4>
<blockquote>
<p>A typical integrator’s Git day.</p>
</blockquote>
<pre class="hljs"><code><div>    $ git status (1)
    $ git branch --no-merged master (2)
    $ mailx (3)
    &amp; s 2 3 4 5 ./+to-apply
    &amp; s 7 8 ./+hold-linus
    &amp; q
    $ git checkout -b topic/one master
    $ git am -3 -i -s ./+to-apply (4)
    $ compile/<span class="hljs-built_in">test</span>
    $ git checkout -b hold/linus &amp;&amp; git am -3 -i -s ./+hold-linus (5)
    $ git checkout topic/one &amp;&amp; git rebase master (6)
    $ git checkout pu &amp;&amp; git reset --hard next (7)
    $ git merge topic/one topic/two &amp;&amp; git merge hold/linus (8)
    $ git checkout maint
    $ git cherry-pick master~4 (9)
    $ compile/<span class="hljs-built_in">test</span>
    $ git tag -s -m <span class="hljs-string">"GIT 0.99.9x"</span> v0.99.9x (10)
    $ git fetch ko &amp;&amp; <span class="hljs-keyword">for</span> branch <span class="hljs-keyword">in</span> master maint next pu (11)
        <span class="hljs-keyword">do</span>
            git show-branch ko/<span class="hljs-variable">$branch</span> <span class="hljs-variable">$branch</span> (12)
        <span class="hljs-keyword">done</span>
    $ git push --follow-tags ko (13)
</div></code></pre>
<pre><code> 1. see what you were in the middle of doing, if anything.
 2. see which branches haven’t been merged into master yet. Likewise
 for any other integration branches e.g.  maint, next and pu
 (potential updates).
 3. read mails, save ones that are applicable, and save others that
 are not quite ready (other mail readers are available).
 4. apply them, interactively, with your sign-offs.
 5. create topic branch as needed and apply, again with sign-offs.
 6. rebase internal topic branch that has not been merged to the
 master or exposed as a part of a stable branch.
 7. restart pu every time from the next.
 8. and bundle topic branches still cooking.
 9. backport a critical fix.
 10. create a signed tag.
 11. make sure master was not accidentally rewound beyond that
 already pushed out.
 12. In the output from git show-branch, master should have
 everything ko/master has, and next should have everything ko/next
 has, etc.
 13. push out the bleeding edge, together with new tags that point
 into the pushed history.
</code></pre>
<blockquote>
<p>In this example, the ko shorthand points at the Git maintainer’s repository at kernel.org, and looks like this:</p>
</blockquote>
<pre class="hljs"><code><div>     (in .git/config)
     [remote "ko"]
             url = kernel.org:/pub/scm/git/git.git
             fetch = refs/heads/*:refs/remotes/ko/*
             push = refs/heads/master
             push = refs/heads/next
             push = +refs/heads/pu
             push = refs/heads/maint
</div></code></pre>
<h2 id="repository-administration">REPOSITORY ADMINISTRATION</h2>
<blockquote>
<p>A repository administrator uses the following tools to set up and maintain access to the repository by developers.</p>
</blockquote>
<ul>
<li>git-daemon(1) to allow anonymous download from repository.</li>
<li>git-shell(1) can be used as a restricted login shell for shared central repository users.</li>
<li>git-http-backend(1) provides a server side implementation Git-over-HTTP (&quot;Smart http&quot;) allowing both fetch and push services.</li>
<li>gitweb(1) provides a web front-end to Git repositories, which can be set-up using the git-instaweb(1) script.</li>
</ul>
<blockquote>
<p><em>update hook howto[1] has a good example of managing a shared central repository.</em></p>
</blockquote>
<blockquote>
<p>In addition there are a number of other widely deployed hosting browsing and reviewing solutions such as:</p>
</blockquote>
<p><code>gitolite, gerrit code review, cgit and others.</code></p>
<h4 id="examples">Examples</h4>
<blockquote>
<p>We assume the following in /etc/services</p>
</blockquote>
<pre>
<code><div>$ grep 9418 /etc/services
git             9418/tcp    <span class="hljs-comment"># Git Version Control System</span>
</div></code></pre>
<blockquote>
<p>Run git-daemon to serve /pub/scm from inetd.
$ grep git /etc/inetd.conf
git     stream  tcp     nowait  nobody <br>
/usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm
<b>[The actual configuration line should be on one line.]</b></p>
</blockquote>
<blockquote>
<p>Run git-daemon to serve /pub/scm from xinetd.</p>
</blockquote>
<pre class="hljs"><code><div>$ cat /etc/xinetd.d/git-daemon
<span class="hljs-comment"># default: off</span>
<span class="hljs-comment"># description: The Git server offers access to Git repositories</span>
service git
{
    <span class="hljs-built_in">disable</span> = no
    <span class="hljs-built_in">type</span>            = UNLISTED
    port            = 9418
    socket_type     = stream
    <span class="hljs-built_in">wait</span>            = no
    user            = nobody
    server          = /usr/bin/git-daemon
    server_args     = --inetd --<span class="hljs-built_in">export</span>-all --base-path=/pub/scm
    log_on_failure  += USERID
}
</div></code></pre>
<p>Check your xinetd(8) documentation and setup, this is from a Fedora
system. Others might be different.</p>
<blockquote>
<p>Give push/pull only access to developers using git-over-ssh.
e.g. those using: <code>$ git push/pull ssh://host.xz/pub/scm/project</code></p>
</blockquote>
<pre class="hljs"><code><div>    $ grep git /etc/passwd (1)
    alice:x:1000:1000::/home/alice:/usr/bin/git-shell
    bob:x:1001:1001::/home/bob:/usr/bin/git-shell
    cindy:x:1002:1002::/home/cindy:/usr/bin/git-shell
    david:x:1003:1003::/home/david:/usr/bin/git-shell
    $ grep git /etc/shells (2)
    /usr/bin/git-shell

     1. <span class="hljs-built_in">log</span>-in shell is <span class="hljs-built_in">set</span> to /usr/bin/git-shell, <span class="hljs-built_in">which</span> does not allow
     anything but git push and git pull. The users require ssh access to
     the machine.
     1. <span class="hljs-keyword">in</span> many distributions /etc/shells needs to list what is used as
     the login shell.
</div></code></pre>
<blockquote>
<p>CVS-style shared repository.</p>
</blockquote>
<pre class="hljs"><code><div>    $ grep git /etc/group (1)
    git:x:9418:alice,bob,cindy,david
    $ <span class="hljs-built_in">cd</span> /home/devo.git
    $ ls -l (2)
    lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -&gt; refs/heads/master
    drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches
    -rw-rw-r--   1 david git    84 Dec  4 22:40 config
    -rw-rw-r--   1 david git    58 Dec  4 22:40 description
    drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks
    -rw-rw-r--   1 david git 37504 Dec  4 22:40 index
    drwxrwsr-x   2 david git  4096 Dec  4 22:40 info
    drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects
    drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs
    drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes
    $ ls -l hooks/update (3)
    -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update
    $ cat info/allowed-users (4)
    refs/heads/master       alice\|cindy
    refs/heads/doc-update   bob
    refs/tags/v[0-9]*       david
</div></code></pre>
<pre><code> 1. place the developers into the same git group.
 2. and make the shared repository writable by the group.
 3. use update-hook example by Carl from Documentation/howto/ for
 branch policy control.
 4. alice and cindy can push into master, only bob can push into
 doc-update. david is the release manager and is the only person who
 can create and push version tags.
</code></pre>
<p>GIT
Part of the git(1) suite</p>
<p>NOTES</p>
<ol>
<li>update hook howto
file:///usr/share/doc/git/html/howto/update-hook-example.html</li>
</ol>
<p>Git 2.17.1                        12/09/2019                    GITEVERYDAY(7)</p>

</body>
</html>
